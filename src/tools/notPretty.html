<html><head><title>This is a title</title><link rel="stylesheet" href="styles.css"></head><body><div style="font-size: 32px; font-weight: bold; text-align: center;">Make your own x86 64-bit operating system</div><div class="standardText"><p><br>Before we start if you want the source code used or extra resources you can find them here {github-link} # Highlight<br><br>What I am using:<br><br>OS:<br>-ubuntu22.04<br><br>Tools:<br>-Git<br>-Qemu<br>-Nasm<br>-NeoVim # You can use whatever editor you want but I use NeoVim<br><br>Command to install the tools used:<br><br></div><div class="highlightedBlock"><p>sudo apt install git qemu qemu-system-x86 nasm neovim<br></div><div class="standardText"><p><br>Enviroment Setup (open up a terminal and run these commands to setup the enviroment):<br><br></div><div class="highlightedBlock"><p>cd<br>cd Downloads # Navigate to the directory where you would like the project<br>mkdir mOS # Or whatever you want to call the project<br>cd mOS<br>touch .gitignore<br>echo "src/bin" > .gitignore<br>mkdir src<br>cd src<br>mkdir bin # This will be for the compiled assembly files<br>touch mbr.asm # This will be the first part of the bootloader<br>touch bootloader.asm # This will be the second part the bootloader<br>touch os.asm # This file will be the payload for the bootloader<br>touch qemu.sh # This file will setup the virtual machine with you operating system<br>ls<br></div><div class="standardText"><p><br>If everything worked you should see something like this (if you copy and pasted from above):<br><br></div><div class="highlightedBlock"><p>{user}@{computerID}:~$ cd<br>cd Downloads # Navigate to the directory where you would like the project<br>mkdir mOS # Or whatever you want to call the project<br>cd mOS<br>touch .gitignore<br>echo "src/bin" > .gitignore<br>mkdir src<br>cd src<br>mkdir bin # This will be for the compiled assembly files<br>touch mbr.asm # This will be the first part of the bootloader<br>touch bootloader.asm # This will be the second part the bootloader<br>touch os.asm # This file will be the payload for the bootloader<br>touch qemu.sh # This file will setup the virtual machine with you operating system<br>ls<br>bin  bootloader.asm  mbr.asm  os.asm  qemu.sh<br>{user}@{computerID]:~/Downloads/mOS/src$<br></div><div class="standardText"><p><br>Now enter the qemu.sh file with your favorite editor:<br><br></div><div class="highlightedBlock"><p>nvim qemu.sh<br></div><div class="standardText"><p><br>Using your favorite editor add this to the qemu.sh file:<br><br>!-- qemu.sh<br>echo "started VM"<br><br>rm -r bin<br>mkdir bin<br><br>nasm mbr.asm -o bin/mbr.bin<br>nasm bootloader.asm -o bin/bootloader.bin<br>nasm os.asm -o bin/os.asm<br>sudo dd if=/dev/zero of=bin/disk.img count=8 bs=1048576<br>cat bin/bootloader.bin bin/os.bin > bin/mos.bin<br>sudo dd if=bin/mbr.bin of=bin/disk.img conv=notrunc<br>sudo dd if=bin/mos.bin of=bin/disk.img bs=512 seek=16 conv=notrunc<br>sudo qemu-system-x86_64 -drive format=raw,file=bin/disk.img<br></div><div class="highlightedBlock"><p><br>Quick overview of the MBR:<br><br>The MBR or Master Boot Record will setup the enviroment for the second stage of our bootloader which will then setup the enviroment for the operating system. The MBR will start in 16 bit mode at the memory offset of 0x7C00 ('0x' before a number mean that the number is in hexadecimal). All x86 CPUs start in 16 bit mode for legacy reason this will be a common theme that our bootloader will have to deal with. -The memory offset location that the bootloader starts with is also for legacy reasons- but in terms of our bootloader the memory offset has little effect whereas we will have to bring the cpu up to 64 bit mode from the current 16 bit mode.<br><br>The very first line of assembly in our bootloader will be telling our assembler that the following code is 16 bit assembly and the second line of code will specify the memory offset that our bootloader will start at.<br><br>note: You use a ";" to mark a comment in nasm assembly.<br>note: The 4 %define statments will be used later.<br><br>--- mbr.asm -<br>%define DAP_SECTORS 64<br>%define DAP_STARTSECTOR 16<br>%define DAP_ADDRESS 0x8000<br>%define DAP_SEGMENT 0x0000<br><br><br><br>BITS 16<br>org 0x7C00 ; This is the standard bootloader start location and should not be changed<br><br></div><div class="standardText"><p><br>The next thing that our bootloader will do are a few things that should be set by default but it is best to explicitly set them.<br><br>--- mbr.asm -<br>entry:<br>cli				; Disable interrupts.<br>cld				; Clear direction flag.<br>xor eax, eax<br>mov ss, ax<br>mov es, ax<br>mov ds, ax<br>mov sp, 0x7C00                  ; The stack moves down from this location.<br>sti				; Enable interrupts.<br><br></div><div class="highlightedBlock"><p><br>Next we will store the drive number that the computer booted from (this is stored in the DL register by the bios on startup).<br><br>--- mbr.asm -<br>mov [DriveNumber], dl		; The bios stored the drive number in the DL register on system startup.<br><br></div><div class="standardText"><p><br>After storeing the drive number into memory we will now configure serial port 0 with the help of a bios interupt (this will be useful for debugging later).<br><br>--- mbr.asm -<br>mov ah, 0<br>mov al, 11100011b		; 9600bps, no parity, 1 stop bit, 8 data bits.<br>mov dx, 0			; Serial port 0.<br>int 0x14			; Configure serial port.<br><br></div><div class="highlightedBlock"><p><br>The next thing the bootloader will do is enable the A20 line, this will give access to the full amount of memory for the system. The A20 line is disabled by default for legacy reasons and limits the system memory to -1mib-.<br><br>--- mbr.asm -<br>; Enable the A20 line -add site talking about the A20 line-<br>setA20:<br>in al, 0x64<br>test al, 0x02<br>jnz set_A20<br>mov al, 0xD1<br>out 0x64, al<br><br>checkA20:<br>in al, 0x64<br>test al, 0x02<br>jnz check_A20<br>mov al, 0xDF<br>out 0x60, al<br><br></div><div class="standardText"><p><br>Now we need to load the 2nd stage of our bootloader lucky we have access to bios interupts, we will also now be using the 4 %define statment from before.<br><br>--- mbr.asm -<br>; Read the 2nd stage boot loader into memory.<br>mov ah, 0x42			; Extended Read<br>mov dl, [DriveNumber]		; Http://www.ctyme.com/intr/rb-0708.htm<br>mov si, DAP<br>int 0x13<br>jc readFail<br><br>; Quick check to make sure the 2nd stage bootloader was read.<br>mov ax, [0x8006]<br>cmp ax, 0x3436			; Compare the signature<br>jne signitureFail<br><br>mov si, msgOK<br>call print16<br><br></div><div class="highlightedBlock"><p><br>We will now jump from 16 bit real mode and enter 32-bit mode protected mode.<br><br>--- mbr.asm -<br>; At this point we are done with real mode and BIOS interrupts. Jump to 32-bit mode.<br>cli				; No more interrupts<br>lgdt [cs:GDTR32]		; Load GDT register<br>mov eax, cr0<br>or al, 0x01			; Set protected mode bit<br>mov cr0, eax<br>jmp 8:0x8000			; Jump to 32-bit protected mode<br><br>readFail:<br>mov si, msgReadFail<br>call print16<br>jmp halt<br>signatureFail:<br>mov si, msgSignatureFail<br>call print16<br>halt:<br>hlt<br>jmp halt<br><br></div><div class="standardText"><p><br>You might notice that we have used a funcion called print16 we will impliment that now<br><br>--- mbr.asm -<br><br>; 16-bit function to output a string to the serial port<br>; Move that start address of the string to the SI register<br>print16:			; Output string in SI to screen<br>pusha<br>mov dx, 0			; Port 0<br>.repeat:<br>mov ah, 0x01			; Serial - Write character to port<br>lodsb				; Get char from string<br>cmp al, 0<br>je .done			; If char is zero, end of string<br>int 0x14			; Output the character<br>jmp short .repeat<br>.done:<br>popa<br>ret<br>;------------------------------------------------------------------------------<br><br>align 16<br>GDTR32:					; Global Descriptors Table Register<br>dw gdt32_end - gdt32 - 1		; Limit of GDT (size minus one)<br>dq gdt32				; Linear address of GDT<br><br>align 16<br>gdt32:<br>dw 0x0000, 0x0000, 0x0000, 0x0000	; Null descriptor<br>dw 0xFFFF, 0x0000, 0x9A00, 0x00CF	; 32-bit code descriptor<br>dw 0xFFFF, 0x0000, 0x9200, 0x00CF	; 32-bit data descriptor<br>gdt32_end:<br><br>msg_Load db 10, "MBR ", 0<br>msg_OK db "OK", 0<br>msg_SigFail db "- Bad Sig!", 0<br>msg_ReadFail db "Failed to read drive!", 0<br><br>times 446-$+$$ db 0<br><br>; False partition table entry required by some BIOS vendors.<br>db 0x80, 0x00, 0x01, 0x00, 0xEB, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF<br>DriveNumber db 0x00<br><br>times 476-$+$$ db 0<br><br>align 4<br><br>DAP:<br>db 0x10<br>db 0x00<br>dw DAP_SECTORS<br>dw DAP_ADDRESS<br>dw DAP_SEGMENT<br>dq DAP_STARTSECTOR<br><br>times 510-$+$$ db 0<br><br>sign dw 0xAA55<br><br>VBEModeInfoBlock: equ 0x5C00<br>; VESA<br>; Mandatory information for all VBE revisions<br>;VBEModeInfoBlock.ModeAttributes		equ VBEModeInfoBlock + 0	; DW - mode attributes<br>;VBEModeInfoBlock.WinAAttributes		equ VBEModeInfoBlock + 2	; DB - window A attributes<br>;VBEModeInfoBlock.WinBAttributes		equ VBEModeInfoBlock + 3	; DB - window B attributes<br>;VBEModeInfoBlock.WinGranularity		equ VBEModeInfoBlock + 4	; DW - window granularity in KB<br>;VBEModeInfoBlock.WinSize		equ VBEModeInfoBlock + 6	; DW - window size in KB<br>;VBEModeInfoBlock.WinASegment		equ VBEModeInfoBlock + 8	; DW - window A start segment<br>;VBEModeInfoBlock.WinBSegment		equ VBEModeInfoBlock + 10	; DW - window B start segment<br>;VBEModeInfoBlock.WinFuncPtr		equ VBEModeInfoBlock + 12	; DD - real mode pointer to window function<br>;VBEModeInfoBlock.BytesPerScanLine	equ VBEModeInfoBlock + 16	; DW - bytes per scan line<br>; Mandatory information for VBE 1.2 and above<br>;VBEModeInfoBlock.XResolution		equ VBEModeInfoBlock + 18	; DW - horizontal resolution in pixels or characters<br>;VBEModeInfoBlock.YResolution		equ VBEModeInfoBlock + 20	; DW - vertical resolution in pixels or characters<br>;VBEModeInfoBlock.XCharSize		equ VBEModeInfoBlock + 22	; DB - character cell width in pixels<br>;VBEModeInfoBlock.YCharSize		equ VBEModeInfoBlock + 23	; DB - character cell height in pixels<br>;VBEModeInfoBlock.NumberOfPlanes		equ VBEModeInfoBlock + 24	; DB - number of memory planes<br>;VBEModeInfoBlock.BitsPerPixel		equ VBEModeInfoBlock + 25	; DB - bits per pixel<br>;VBEModeInfoBlock.NumberOfBanks		equ VBEModeInfoBlock + 26	; DB - number of banks<br>;VBEModeInfoBlock.MemoryModel		equ VBEModeInfoBlock + 27	; DB - memory model type<br>;VBEModeInfoBlock.BankSize		equ VBEModeInfoBlock + 28	; DB - bank size in KB<br>;VBEModeInfoBlock.NumberOfImagePages	equ VBEModeInfoBlock + 29	; DB - number of image pages<br>;VBEModeInfoBlock.Reserved		equ VBEModeInfoBlock + 30	; DB - reserved (0x00 for VBE 1.0-2.0, 0x01 for VBE 3.0)<br>; Direct Color fields (required for direct/6 and YUV/7 memory models)<br>;VBEModeInfoBlock.RedMaskSize		equ VBEModeInfoBlock + 31	; DB - size of direct color red mask in bits<br>;VBEModeInfoBlock.RedFieldPosition	equ VBEModeInfoBlock + 32	; DB - bit position of lsb of red mask<br>;VBEModeInfoBlock.GreenMaskSize		equ VBEModeInfoBlock + 33	; DB - size of direct color green mask in bits<br>;VBEModeInfoBlock.GreenFieldPosition	equ VBEModeInfoBlock + 34	; DB - bit position of lsb of green mask<br>;VBEModeInfoBlock.BlueMaskSize		equ VBEModeInfoBlock + 35	; DB - size of direct color blue mask in bits<br>;VBEModeInfoBlock.BlueFieldPosition	equ VBEModeInfoBlock + 36	; DB - bit position of lsb of blue mask<br>;VBEModeInfoBlock.RsvdMaskSize		equ VBEModeInfoBlock + 37	; DB - size of direct color reserved mask in bits<br>;VBEModeInfoBlock.RsvdFieldPosition	equ VBEModeInfoBlock + 38	; DB - bit position of lsb of reserved mask<br>;VBEModeInfoBlock.DirectColorModeInfo	equ VBEModeInfoBlock + 39	; DB - direct color mode attributes<br>; Mandatory information for VBE 2.0 and above<br>;VBEModeInfoBlock.PhysBasePtr		equ VBEModeInfoBlock + 40	; DD - physical address for flat memory frame buffer<br>;VBEModeInfoBlock.Reserved1		equ VBEModeInfoBlock + 44	; DD - Reserved - always set to 0<br>;VBEModeInfoBlock.Reserved2		equ VBEModeInfoBlock + 48	; DD - Reserved - always set to 0<br><br>; EOF<br>