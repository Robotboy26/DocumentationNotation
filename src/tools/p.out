sudo apt install git qemu qemu-system-x86 nasm neovim
cd
cd Downloads # Navigate to the directory where you would like the project
mkdir mOS # Or whatever you want to call the project
cd mOS
touch .gitignore
echo "src/bin" > .gitignore
mkdir src
cd src
mkdir bin # This will be for the compiled assembly files
touch mbr.asm # This will be the first part of the bootloader
touch bootloader.asm # This will be the second part the bootloader
touch os.asm # This file will be the payload for the bootloader
touch qemu.sh # This file will setup the virtual machine with you operating system
ls
{user}@{computerID}:~$ cd
cd Downloads # Navigate to the directory where you would like the project
mkdir mOS # Or whatever you want to call the project
cd mOS
touch .gitignore
echo "src/bin" > .gitignore
mkdir src
cd src
mkdir bin # This will be for the compiled assembly files
touch mbr.asm # This will be the first part of the bootloader
touch bootloader.asm # This will be the second part the bootloader
touch os.asm # This file will be the payload for the bootloader
touch qemu.sh # This file will setup the virtual machine with you operating system
ls
bin  bootloader.asm  mbr.asm  os.asm  qemu.sh
{user}@{computerID]:~/Downloads/mOS/src$
nvim qemu.sh
echo "started VM"

rm -r bin
mkdir bin

nasm mbr.asm -o bin/mbr.bin
nasm bootloader.asm -o bin/bootloader.bin
nasm os.asm -o bin/os.asm
sudo dd if=/dev/zero of=bin/disk.img count=8 bs=1048576
cat bin/bootloader.bin bin/os.bin > bin/mos.bin
sudo dd if=bin/mbr.bin of=bin/disk.img conv=notrunc
sudo dd if=bin/mos.bin of=bin/disk.img bs=512 seek=16 conv=notrunc
sudo qemu-system-x86_64 -drive format=raw,file=bin/disk.img
%define DAP_SECTORS 64
%define DAP_STARTSECTOR 16
%define DAP_ADDRESS 0x8000
%define DAP_SEGMENT 0x0000



BITS 16
org 0x7C00 ; This is the standard bootloader start location and should not be changed

entry:
	cli				; Disable interrupts.
	cld				; Clear direction flag.
	xor eax, eax
	mov ss, ax
	mov es, ax
	mov ds, ax
	mov sp, 0x7C00                  ; The stack moves down from this location.
	sti				; Enable interrupts.

	mov [DriveNumber], dl		; The bios stored the drive number in the DL register on system startup.

	mov ah, 0
	mov al, 11100011b		; 9600bps, no parity, 1 stop bit, 8 data bits.
	mov dx, 0			; Serial port 0.
	int 0x14			; Configure serial port.

; Enable the A20 line -add site talking about the A20 line-
setA20:
	in al, 0x64
	test al, 0x02
	jnz set_A20
	mov al, 0xD1
	out 0x64, al

checkA20:
	in al, 0x64
	test al, 0x02
	jnz check_A20
	mov al, 0xDF
	out 0x60, al

; Read the 2nd stage boot loader into memory.
mov ah, 0x42			; Extended Read
mov dl, [DriveNumber]		; Http://www.ctyme.com/intr/rb-0708.htm
mov si, DAP
int 0x13
jc readFail

; Quick check to make sure the 2nd stage bootloader was read.
mov ax, [0x8006]
cmp ax, 0x3436			; Compare the signature
jne signitureFail

mov si, msgOK
call print16

; At this point we are done with real mode and BIOS interrupts. Jump to 32-bit mode.
cli				; No more interrupts
lgdt [cs:GDTR32]		; Load GDT register
mov eax, cr0
or al, 0x01			; Set protected mode bit
mov cr0, eax
jmp 8:0x8000			; Jump to 32-bit protected mode

readFail:
	mov si, msgReadFail
	call print16
	jmp halt
signatureFail:
	mov si, msgSignatureFail
	call print16
halt:
	hlt
	jmp halt


; 16-bit function to output a string to the serial port
; Move that start address of the string to the SI register
print16:			; Output string in SI to screen
	pusha
	mov dx, 0			; Port 0
.repeat:
	mov ah, 0x01			; Serial - Write character to port
	lodsb				; Get char from string
	cmp al, 0
	je .done			; If char is zero, end of string
	int 0x14			; Output the character
	jmp short .repeat
.done:
	popa
	ret
;------------------------------------------------------------------------------

align 16
GDTR32:					; Global Descriptors Table Register
dw gdt32_end - gdt32 - 1		; Limit of GDT (size minus one)
dq gdt32				; Linear address of GDT

align 16
gdt32:
dw 0x0000, 0x0000, 0x0000, 0x0000	; Null descriptor
dw 0xFFFF, 0x0000, 0x9A00, 0x00CF	; 32-bit code descriptor
dw 0xFFFF, 0x0000, 0x9200, 0x00CF	; 32-bit data descriptor
gdt32_end:

msg_Load db 10, "MBR ", 0
msg_OK db "OK", 0
msg_SigFail db "- Bad Sig!", 0
msg_ReadFail db "Failed to read drive!", 0

times 446-$+$$ db 0

; False partition table entry required by some BIOS vendors.
db 0x80, 0x00, 0x01, 0x00, 0xEB, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF
DriveNumber db 0x00

times 476-$+$$ db 0

align 4

DAP:
	db 0x10
	db 0x00
	dw DAP_SECTORS
	dw DAP_ADDRESS
	dw DAP_SEGMENT
	dq DAP_STARTSECTOR

times 510-$+$$ db 0

sign dw 0xAA55

VBEModeInfoBlock: equ 0x5C00
; VESA
; Mandatory information for all VBE revisions
;VBEModeInfoBlock.ModeAttributes		equ VBEModeInfoBlock + 0	; DW - mode attributes
;VBEModeInfoBlock.WinAAttributes		equ VBEModeInfoBlock + 2	; DB - window A attributes
;VBEModeInfoBlock.WinBAttributes		equ VBEModeInfoBlock + 3	; DB - window B attributes
;VBEModeInfoBlock.WinGranularity		equ VBEModeInfoBlock + 4	; DW - window granularity in KB
;VBEModeInfoBlock.WinSize		equ VBEModeInfoBlock + 6	; DW - window size in KB
;VBEModeInfoBlock.WinASegment		equ VBEModeInfoBlock + 8	; DW - window A start segment
;VBEModeInfoBlock.WinBSegment		equ VBEModeInfoBlock + 10	; DW - window B start segment
;VBEModeInfoBlock.WinFuncPtr		equ VBEModeInfoBlock + 12	; DD - real mode pointer to window function
;VBEModeInfoBlock.BytesPerScanLine	equ VBEModeInfoBlock + 16	; DW - bytes per scan line
; Mandatory information for VBE 1.2 and above
;VBEModeInfoBlock.XResolution		equ VBEModeInfoBlock + 18	; DW - horizontal resolution in pixels or characters
;VBEModeInfoBlock.YResolution		equ VBEModeInfoBlock + 20	; DW - vertical resolution in pixels or characters
;VBEModeInfoBlock.XCharSize		equ VBEModeInfoBlock + 22	; DB - character cell width in pixels
;VBEModeInfoBlock.YCharSize		equ VBEModeInfoBlock + 23	; DB - character cell height in pixels
;VBEModeInfoBlock.NumberOfPlanes		equ VBEModeInfoBlock + 24	; DB - number of memory planes
;VBEModeInfoBlock.BitsPerPixel		equ VBEModeInfoBlock + 25	; DB - bits per pixel
;VBEModeInfoBlock.NumberOfBanks		equ VBEModeInfoBlock + 26	; DB - number of banks
;VBEModeInfoBlock.MemoryModel		equ VBEModeInfoBlock + 27	; DB - memory model type
;VBEModeInfoBlock.BankSize		equ VBEModeInfoBlock + 28	; DB - bank size in KB
;VBEModeInfoBlock.NumberOfImagePages	equ VBEModeInfoBlock + 29	; DB - number of image pages
;VBEModeInfoBlock.Reserved		equ VBEModeInfoBlock + 30	; DB - reserved (0x00 for VBE 1.0-2.0, 0x01 for VBE 3.0)
; Direct Color fields (required for direct/6 and YUV/7 memory models)
;VBEModeInfoBlock.RedMaskSize		equ VBEModeInfoBlock + 31	; DB - size of direct color red mask in bits
;VBEModeInfoBlock.RedFieldPosition	equ VBEModeInfoBlock + 32	; DB - bit position of lsb of red mask
;VBEModeInfoBlock.GreenMaskSize		equ VBEModeInfoBlock + 33	; DB - size of direct color green mask in bits
;VBEModeInfoBlock.GreenFieldPosition	equ VBEModeInfoBlock + 34	; DB - bit position of lsb of green mask
;VBEModeInfoBlock.BlueMaskSize		equ VBEModeInfoBlock + 35	; DB - size of direct color blue mask in bits
;VBEModeInfoBlock.BlueFieldPosition	equ VBEModeInfoBlock + 36	; DB - bit position of lsb of blue mask
;VBEModeInfoBlock.RsvdMaskSize		equ VBEModeInfoBlock + 37	; DB - size of direct color reserved mask in bits
;VBEModeInfoBlock.RsvdFieldPosition	equ VBEModeInfoBlock + 38	; DB - bit position of lsb of reserved mask
;VBEModeInfoBlock.DirectColorModeInfo	equ VBEModeInfoBlock + 39	; DB - direct color mode attributes
; Mandatory information for VBE 2.0 and above
;VBEModeInfoBlock.PhysBasePtr		equ VBEModeInfoBlock + 40	; DD - physical address for flat memory frame buffer
;VBEModeInfoBlock.Reserved1		equ VBEModeInfoBlock + 44	; DD - Reserved - always set to 0
;VBEModeInfoBlock.Reserved2		equ VBEModeInfoBlock + 48	; DD - Reserved - always set to 0

; EOF